// Copyright 2020 Western Digital Corporation or its affiliates.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// This file contains the methods of the class Hart supporting
// the RISCV floating point instructions.

#include <cfenv>
#include <cmath>
#include <array>
#include "DecodedInst.hpp"
#include "Hart.hpp"
#include "instforms.hpp"
#include "float-util.hpp"


using namespace WdRiscv;


template <typename URV>
void
Hart<URV>::enableRvf(bool flag)
{
  enableExtension(RvExtension::F, flag);
  csRegs_.enableRvf(flag);
  if (not flag and not isRvs())
    setFpStatus(FpStatus::Off);
}


template <typename URV>
void
Hart<URV>::resetFloat()
{
  // Enable FP in MSTATUS.FS if f/d/zfh extension present and linux/newlib.
  bool hasFp = isRvf() or isRvd() or isRvzfh();
  if (hasFp and (newlib_ or linux_))
    {
      URV val = csRegs_.peekMstatus();
      MstatusFields<URV> fields(val);
      fields.bits_.FS = unsigned(FpStatus::Initial);
      csRegs_.write(CsrNumber::MSTATUS, PrivilegeMode::Machine, fields.value_);
    }

  if (hasFp)
    {
      unsigned flen = 16;
      if (isRvf())
	flen = 32;
      if (isRvd())
	flen = 64;
      fpRegs_.setFlen(flen);
      fpRegs_.reset(isRvzfh(), isRvf(), isRvd());
    }

  clearSimulatorFpFlags();
}


template <typename URV>
void
Hart<URV>::orFcsrFlags(FpFlags flags)
{
  if (triggerTripped_)
    return;

  fpRegs_.setLastFpFlags(unsigned(flags));

  auto prev = getFpFlags();
  auto val = prev | unsigned(flags);
  if (val != prev)
    {
      setFpFlags(val);
      recordCsrWrite(CsrNumber::FCSR);
    }

  // Mark FS as dirty if the instruction generated any FP flags even if they
  // are the same as the current flags.
  if (unsigned(flags))
    markFsDirty();
}


template <typename URV>
inline
RoundingMode
Hart<URV>::effectiveRoundingMode(unsigned instMode)
{
  if (forceRounding_)
    return forcedRounding_;

  if (RoundingMode(instMode) != RoundingMode::Dynamic)
    return RoundingMode(instMode);

  return getFpRoundingMode();
}


#ifdef FAST_SLOPPY

template <typename URV>
inline
void
Hart<URV>::updateAccruedFpBits()
{
}


template <typename URV>
inline
void
Hart<URV>::setFpStatus(FpStatus)
{
}


template <typename URV>
inline
void
Hart<URV>::markFsDirty()
{
}


#else


template <typename URV>
void
Hart<URV>::updateAccruedFpBits()
{
  if (triggerTripped_)
    return;

  URV val = getFpFlags();
  URV prev = val;

  URV incFlags = activeSimulatorFpFlags(); // Incremental RISCV FP flags generated by current instruction.

  fpRegs_.setLastFpFlags(incFlags);

  val |= incFlags;
  if (val != prev)
    {
      setFpFlags(val);
      recordCsrWrite(CsrNumber::FCSR);
    }

  // Mark FS as dirty if the instruction generated any FP flags even if they
  // are the same as the current flags.
  if (incFlags)
    markFsDirty();
}


template <typename URV>
void
Hart<URV>::setFpStatus(FpStatus value)
{
  if (mstatus_.bits_.FS != unsigned(value))
    {
      mstatus_.bits_.FS = unsigned(value);
      writeMstatus();
    }

  if (virtMode_ and vsstatus_.bits_.FS != unsigned(value))
    {
      vsstatus_.bits_.FS = unsigned(value);
      csRegs_.poke(CsrNumber::VSSTATUS, vsstatus_.value_);
      recordCsrWrite(CsrNumber::VSSTATUS);
      updateCachedVsstatus();
    }
}


template <typename URV>
inline
void
Hart<URV>::markFsDirty()
{
  setFpStatus(FpStatus::Dirty);
}


#endif


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeCommon(const DecodedInst* di)
{
  RoundingMode riscvMode = effectiveRoundingMode(di->roundingMode());
  if (riscvMode >= RoundingMode::Invalid1)
    {
      illegalInst(di);
      return false;
    }

  clearSimulatorFpFlags();
  setSimulatorRoundingMode(riscvMode);
  return true;
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeHp(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeSp(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeDp(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeBf16(const DecodedInst* di)
{
  if (not isZfbfminLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
void
Hart<URV>::execFlw(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint32_t>(virtAddr, false /*hyper*/, data))
    {
      fpRegs_.writeSingle(di->op0(), std::bit_cast<float>(static_cast<uint32_t>(data)));
      markFsDirty();
    }
}


template <typename URV>
void
Hart<URV>::execFsw(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1(), rs2 = di->op0();
  SRV imm = di->op2As<SRV>();

  URV base = intRegs_.read(rs1);
  URV addr = base + imm;

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t val = fpRegs_.readBitsRaw(rs2);

  store<uint32_t>(addr, false /*hyper*/, uint32_t(val));
}


template <typename URV>
void
Hart<URV>::execFmadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = -fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = -fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  float f1 = -fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = -fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFadd(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFsub(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmul_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFmul(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFdiv_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFdiv(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsqrt_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  float res = doFsqrt(f1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnj_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = std::copysignf(f1, f2);  // Magnitude of rs1 and sign of rs2
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjn_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  unsigned sign = std::signbit(f2);

  float x = sign? 1 : -1;

  float res = std::copysignf(f1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjx_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  int sign1 = (std::signbit(f1) == 0) ? 0 : 1;
  int sign2 = (std::signbit(f2) == 0) ? 0 : 1;
  int sign = sign1 ^ sign2;

  float x = sign? -1 : 1;

  float res = std::copysignf(f1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmin_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fminf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0F);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmax_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmaxf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0F);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_w_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  SRV result = fpConvertTo<int32_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <typename URV>
void
Hart<URV>::execFcvt_wu_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(f1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <typename URV>
void
Hart<URV>::execFmv_x_w(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
  int32_t  s1 = static_cast<int32_t>(v1);  // Keep lower 32 bits

  SRV value = SRV(s1); // Sign extend.

  intRegs_.write(di->op0(), value);
}

 
template <typename URV>
void
Hart<URV>::execFeq_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (f1 == f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFlt_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 < f2)? 1 : 0;
    
  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFle_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename FT>
unsigned
WdRiscv::fpClassifyRiscv(FT val)
{
  unsigned result = 0;

  bool pos = not std::signbit(val);
  int type = std::fpclassify(val);

  if (type == FP_INFINITE)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosInfinity);
      else
	result |= unsigned(FpClassifyMasks::NegInfinity);
    }
  else if (type == FP_NORMAL)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosNormal);
      else
	result |= unsigned(FpClassifyMasks::NegNormal);
    }
  else if (type == FP_SUBNORMAL)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosSubnormal);
      else
	result |= unsigned(FpClassifyMasks::NegSubnormal);
    }
  else if (type == FP_ZERO)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosZero);
      else
	result |= unsigned(FpClassifyMasks::NegZero);
    }
  else if (type == FP_NAN)
    {
      if (isSnan(val))
	result |= unsigned(FpClassifyMasks::SignalingNan);
      else
	result |= unsigned(FpClassifyMasks::QuietNan);
    }

  return result;
}


template <typename URV>
void
Hart<URV>::execFclass_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  URV result = fpClassifyRiscv(f1);
  intRegs_.write(di->op0(), result);
}


template <typename URV>
void
Hart<URV>::execFcvt_s_w(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_wu(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  uint32_t u1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(u1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmv_w_x(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t u1 = intRegs_.read(di->op1());

  fpRegs_.writeSingle(di->op0(), std::bit_cast<float>(u1));

  markFsDirty();
}


template <>
void
Hart<uint32_t>::execFcvt_l_s(const DecodedInst* di)
{
  illegalInst(di);  // fcvt.l.s is not an RV32 instruction.
}


template <>
void
Hart<uint64_t>::execFcvt_l_s(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <>
void
Hart<uint32_t>::execFcvt_lu_s(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.lu.s
}


template <>
void
Hart<uint64_t>::execFcvt_lu_s(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <>
void
Hart<uint32_t>::execFcvt_s_l(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.lu.s
}


template <>
void
Hart<uint64_t>::execFcvt_s_l(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  SRV i1 = static_cast<SRV>(intRegs_.read(di->op1()));

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <>
void
Hart<uint32_t>::execFcvt_s_lu(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.s.lu
}


template <>
void
Hart<uint64_t>::execFcvt_s_lu(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  URV i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFld(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint64_t>(virtAddr, false /*hyper*/, data))
    {
      fpRegs_.writeDouble(di->op0(), std::bit_cast<double>(data));
      markFsDirty();
    }
}


template <typename URV>
void
Hart<URV>::execFsd(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1();
  uint32_t rs2 = di->op0();

  URV base = intRegs_.read(rs1);
  URV addr = base + di->op2As<SRV>();
  double val = fpRegs_.readDouble(rs2);

  store<uint64_t>(addr, false /*hyper*/, std::bit_cast<uint64_t>(val));
}


template <typename URV>
void
Hart<URV>::execFmadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = -fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = -fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  double f1 = -fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = -fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFadd(d1, d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFadd(d1, -d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmul_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFmul(d1, d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFdiv_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFdiv(d1, d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnj_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = copysign(d1, d2);  // Magnitude of rs1 and sign of rs2
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjn_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  unsigned sign = std::signbit(d2);

  double x = sign? 1 : -1;

  double res = copysign(d1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjx_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  int sign1 = (std::signbit(d1) == 0) ? 0 : 1;
  int sign2 = (std::signbit(d2) == 0) ? 0 : 1;
  int sign = sign1 ^ sign2;

  double x = sign? -1 : 1;

  double res = copysign(d1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmin_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmax_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_s(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  double res = fpConvertTo<double, true>(f1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  float res = fpConvertTo<float, false>(d1);
  res       = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsqrt_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  double res = doFsqrt(d1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFle_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (d1 <= d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFlt_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (d1 < d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFeq_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    {
      if (isSnan(d1) or isSnan(d2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (d1 == d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFcvt_w_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  SRV result = fpConvertTo<int32_t>(d1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}



template <typename URV>
void
Hart<URV>::execFcvt_wu_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(d1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <typename URV>
void
Hart<URV>::execFcvt_d_w(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_wu(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  uint32_t i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFclass_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  URV result = fpClassifyRiscv(d1);
  intRegs_.write(di->op0(), result);
}


template <>
void
Hart<uint32_t>::execFcvt_l_d(const DecodedInst* di)
{
  illegalInst(di);  // fcvt.l.d not available in RV32
}


template <>
void
Hart<uint64_t>::execFcvt_l_d(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <>
void
Hart<uint32_t>::execFcvt_lu_d(const DecodedInst* di)
{
  illegalInst(di);  /// fcvt.lu.d is not available in RV32.
}


template <>
void
Hart<uint64_t>::execFcvt_lu_d(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <typename URV>
void
Hart<URV>::execFcvt_d_l(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_lu(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  URV i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmv_d_x(const DecodedInst* di)
{
  if (not isRv64() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  uint64_t u1 = intRegs_.read(di->op1());

  fpRegs_.writeDouble(di->op0(), std::bit_cast<double>(u1));

  markFsDirty();
}


// In 32-bit harts, fmv_x_d is an illegal instruction.
template <>
void
Hart<uint32_t>::execFmv_x_d(const DecodedInst* di)
{
  illegalInst(di);
}


template <>
void
Hart<uint64_t>::execFmv_x_d(const DecodedInst* di)
{
  if (not isRv64() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  URV v1 = fpRegs_.readBitsRaw(di->op1());
  intRegs_.write(di->op0(), v1);
}


template<typename URV>
void
Hart<URV>::execFlh(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint16_t>(virtAddr, false /*hyper*/,  data))
    {
      fpRegs_.writeHalf(di->op0(), std::bit_cast<Float16>(static_cast<uint16_t>(data)));
      markFsDirty();
    }
}


template<typename URV>
void
Hart<URV>::execFsh(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1(), rs2 = di->op0();
  SRV imm = di->op2As<SRV>();

  URV base = intRegs_.read(rs1);
  URV addr = base + imm;

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint16_t val = fpRegs_.readBitsRaw(rs2);

  store<uint16_t>(addr, false /*hyper*/, val);
}


template<typename URV>
void
Hart<URV>::execFmadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = -fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFnmsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = -fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFnmadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  Float16 f1 = -fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = -fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFadd(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFsub(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmul_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFmul(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFdiv_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFdiv(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsqrt_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  Float16 res = doFsqrt(f1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnj_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = std::copysign(f1, f2);  // Magnitude of f1 and sign of f2
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnjn_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  unsigned sign = std::signbit(f2);

  Float16 x = sign? Float16{} : -Float16{};

  Float16 res = std::copysign(f1, x);
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnjx_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  unsigned sign1 = std::signbit(f1);
  unsigned sign2 = std::signbit(f2);
  unsigned sign = sign1 ^ sign2;

  Float16 x = sign? -Float16{} : Float16{};

  Float16 res = std::copysign(f1, x);
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmin_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -Float16{});  // Make sure min(-0, +0) is -0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmax_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, Float16{});  // Make sure max(-0, +0) is +0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_s_h(const DecodedInst* di)
{
  // Half to single

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  float res = fpConvertTo<float, true>(f1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_d_h(const DecodedInst* di)
{
  // Half to double

  if (not isRvd() or (not isZfhLegal() and not isZfhminLegal()))
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  double res = fpConvertTo<double, true>(f1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_s(const DecodedInst* di)
{
  // Single to half.

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  Float16 res = fpConvertTo<Float16, false>(f1);
  res         = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_d(const DecodedInst* di)
{
  // Double to half.

  if (not isRvd() or (not isZfhLegal() and not isZfhminLegal()))
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  Float16 res = fpConvertTo<Float16, false>(d1);
  res         = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_w_h(const DecodedInst* di)
{
  // Half to integer word.

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  SRV result = fpConvertTo<int32_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template<typename URV>
void
Hart<URV>::execFcvt_wu_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(f1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template<typename URV>
void
Hart<URV>::execFmv_x_h(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
  int16_t  s1 = static_cast<int16_t>(v1);  // Keep lower 16 bits

  SRV value = SRV(s1); // Sign extend.

  intRegs_.write(di->op0(), value);
}


template<typename URV>
void
Hart<URV>::execFeq_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (f1 == f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFlt_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 < f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFle_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFclass_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  URV result = fpClassifyRiscv(f1);
  intRegs_.write(di->op0(), result);
}


template<typename URV>
void
Hart<URV>::execFcvt_h_w(const DecodedInst* di)
{
  // Integer word to half fp.

  if (not checkRoundingModeHp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(i1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_wu(const DecodedInst* di)
{
  // Integer word to half fp.

  if (not checkRoundingModeHp(di))
    return;

  uint32_t u1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(u1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmv_h_x(const DecodedInst* di)
{
  // move bits of integer register to half fp

  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  URV u1 = intRegs_.read(di->op1());

  fpRegs_.writeHalf(di->op0(), std::bit_cast<Float16>(static_cast<uint16_t>(u1)));

  markFsDirty();
}


template<>
void
Hart<uint32_t>::execFcvt_l_h(const DecodedInst* di)
{
  illegalInst(di);
}

template <>
void
Hart<uint64_t>::execFcvt_l_h(const DecodedInst* di)
{
  // half-precision to uin64_t

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template<>
void
Hart<uint32_t>::execFcvt_lu_h(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_lu_h(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template<>
void
Hart<uint32_t>::execFcvt_h_l(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_h_l(const DecodedInst* di)
{
  // int64_t to half fp

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  SRV i1 = static_cast<SRV>(intRegs_.read(di->op1()));

  Float16 res = fpConvertTo<Float16>(i1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<>
void
Hart<uint32_t>::execFcvt_h_lu(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_h_lu(const DecodedInst* di)
{
  // uint64_t to half fp

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  URV u1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(u1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvtmod_w_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  clearSimulatorFpFlags();

  double d1 = fpRegs_.readDouble(di->op1());

  SRV result;
  if (std::isinf(d1) or std::isnan(d1))
    {
      result = 0;
      raiseSimulatorFpFlags(FpFlags::Invalid);
    }
  else
    {
      int    exp;
      double frac  = std::frexp(d1, &exp);
      if (exp < 1)
        {
          result = 0;
          if (std::fpclassify(frac) != FP_ZERO)
            raiseSimulatorFpFlags(FpFlags::Inexact);
        }
      else
        {
          if (exp >= (64 + std::numeric_limits<double>::digits))
            result = 0;
          else
            {
              // Clear the sign bit and exponent bits
              frac = std::ldexp(std::fabs(frac),
                                std::numeric_limits<double>::min_exponent);

              int      shift    = exp - std::numeric_limits<double>::digits;
              uint64_t result64 = std::bit_cast<uint64_t>(frac);
              if (shift > 0)
                result64 <<= shift;
              else
                result64 >>= -shift;
	      int32_t result32 = result64;
              if (std::signbit(d1))
                result32 = -result32;
	      result = result32;  // Sign extend.
            }
          if (exp > std::numeric_limits<int32_t>::digits)
            raiseSimulatorFpFlags(FpFlags::Invalid);
          else if (result != d1)
            raiseSimulatorFpFlags(FpFlags::Inexact);
        }
    }

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <typename T>
static constexpr
auto
getFliValueTable()
{
  constexpr auto valueTable = std::array
    {
      static_cast<T>(-1.0f),
      std::numeric_limits<T>::min(),
      static_cast<T>(0x1p-16f),
      static_cast<T>(0x1p-15f),
      static_cast<T>(0x1p-8f),
      static_cast<T>(0x1p-7f),
      static_cast<T>(0.0625f),
      static_cast<T>(0.125f),
      static_cast<T>(0.25f),
      static_cast<T>(0.3125f),
      static_cast<T>(0.375f),
      static_cast<T>(0.4375f),
      static_cast<T>(0.5f),
      static_cast<T>(0.625f),
      static_cast<T>(0.75f),
      static_cast<T>(0.875f),
      static_cast<T>(1.0f),
      static_cast<T>(1.25f),
      static_cast<T>(1.5f),
      static_cast<T>(1.75f),
      static_cast<T>(2.0f),
      static_cast<T>(2.5f),
      static_cast<T>(3.0f),
      static_cast<T>(4.0f),
      static_cast<T>(8.0f),
      static_cast<T>(16.0f),
      static_cast<T>(128.0f),
      static_cast<T>(256.0f),
      static_cast<T>(0x1p15f),
      static_cast<T>(0x1p16f),
      std::numeric_limits<T>::infinity(),
      std::numeric_limits<T>::quiet_NaN(),
    };
  static_assert(std::size(valueTable) == 32);

  return valueTable;
}


template <typename URV>
void
Hart<URV>::execFli_h(const DecodedInst* di)
{
  static constexpr auto valueTable = getFliValueTable<Float16>();

  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 res = valueTable.at(di->op1());

  fpRegs_.writeHalf(di->op0(), res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFli_s(const DecodedInst* di)
{
  static constexpr auto valueTable = getFliValueTable<float>();

  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float res = valueTable.at(di->op1());

  fpRegs_.writeSingle(di->op0(), res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFli_d(const DecodedInst* di)
{
  static constexpr auto valueTable = getFliValueTable<double>();

  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  double res = valueTable.at(di->op1());

  fpRegs_.writeDouble(di->op0(), res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFleq_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
      res = 0;
    }
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);

}


template <typename URV>
void
Hart<URV>::execFleq_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
      res = 0;
    }
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFleq_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    {
      if (isSnan(d1) or isSnan(d2))
        orFcsrFlags(FpFlags::Invalid);
      res = 0;
    }
  else
    res = (d1 <= d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFltq_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
      res = 0;
    }
  else
    res = (f1 < f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFltq_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
      res = 0;
    }
  else
    res = (f1 < f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFltq_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    {
      if (isSnan(d1) or isSnan(d2))
        orFcsrFlags(FpFlags::Invalid);
      res = 0;
    }
  else
    res = (d1 < d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFmaxm_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }
  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, Float16{});  // Make sure max(-0, +0) is +0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmaxm_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else
    res = std::fmaxf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0F);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmaxm_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }
  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFminm_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else
    res = std::fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -Float16{});  // Make sure min(-0, +0) is -0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFminm_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }
  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else
    res = std::fminf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0F);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFminm_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else
    res = fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmvh_x_d(const DecodedInst* di)
{
  if (mxlen_ == 32)
    {
      if (not isRvzfa() or not isDpLegal())
	{
	  illegalInst(di);
	  return;
	}
      uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
      v1 >>= 32;
      intRegs_.write(di->op0(), v1);
    }
  else
    illegalInst(di);
}


template <typename URV>
void
Hart<URV>::execFmvp_d_x(const DecodedInst* di)
{
  if (mxlen_ == 32)
    {
      if (not isRvzfa() or not isDpLegal())
	{
	  illegalInst(di);
	  return;
	}
      uint32_t v1 = intRegs_.read(di->op1());
      uint32_t v2 = intRegs_.read(di->op2());
      uint64_t v0 = (uint64_t(v2) << 32) | v1;
      fpRegs_.writeDouble(di->op0(), std::bit_cast<double>(v0));
      markFsDirty();
    }
  else
    illegalInst(di);
}


template <typename URV>
void
Hart<URV>::execFround_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeCommon(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f0 = doFround<false>(f1);

  fpRegs_.writeHalf(di->op0(), f0);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFround_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeCommon(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f0 = doFround<false>(f1);

  fpRegs_.writeSingle(di->op0(), f0);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFround_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeCommon(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d0 = doFround<false>(d1);

  fpRegs_.writeDouble(di->op0(), d0);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFroundnx_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeCommon(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f0 = doFround<true>(f1);

  fpRegs_.writeHalf(di->op0(), f0);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFroundnx_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeCommon(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f0 = doFround<true>(f1);

  fpRegs_.writeSingle(di->op0(), f0);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFroundnx_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeCommon(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d0 = doFround<true>(d1);

  fpRegs_.writeDouble(di->op0(), d0);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_bf16_s(const DecodedInst* di)
{
  // Single to bfloat16.

  if (not checkRoundingModeBf16(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  BFloat16 res = fpConvertTo<BFloat16, false>(f1);
  res          = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeBFloat16(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_bf16(const DecodedInst* di)
{
  if (not checkRoundingModeBf16(di))
    return;

  BFloat16 bf1 = fpRegs_.readBFloat16(di->op1());

  float res = fpConvertTo<float, true>(bf1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template class WdRiscv::Hart<uint32_t>;
template class WdRiscv::Hart<uint64_t>;

template unsigned WdRiscv::fpClassifyRiscv<Float16>(Float16);
template unsigned WdRiscv::fpClassifyRiscv<BFloat16>(BFloat16);
template unsigned WdRiscv::fpClassifyRiscv<float>(float);
template unsigned WdRiscv::fpClassifyRiscv<double>(double);
