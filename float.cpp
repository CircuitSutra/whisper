// Copyright 2020 Western Digital Corporation or its affiliates.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// This file contains the methods of the class Hart supporting
// the RISCV floating point instructions.

#include <cfenv>
#include <cmath>
#include <array>
#include "float-convert-helpers.hpp"
#include "Hart.hpp"
#include "instforms.hpp"
#include "softfloat-util.hpp"

#ifdef __x86_64__
#include <emmintrin.h>
#endif


using namespace WdRiscv;


template <typename URV>
void
Hart<URV>::enableRvf(bool flag)
{
  enableExtension(RvExtension::F, flag);
  csRegs_.enableRvf(flag);
  if (not flag)
    setFpStatus(FpStatus::Off);
}


template <typename URV>
void
Hart<URV>::resetFloat()
{
  // Enable FP in MSTATUS.FS if f/d/zfh extension present and linux/newlib.
  bool hasFp = isRvf() or isRvd() or isRvzfh();
  if (hasFp and (newlib_ or linux_))
    {
      URV val = csRegs_.peekMstatus();
      MstatusFields<URV> fields(val);
      fields.bits_.FS = unsigned(FpStatus::Initial);
      csRegs_.write(CsrNumber::MSTATUS, PrivilegeMode::Machine, fields.value_);
    }

  if (hasFp)
    {
      unsigned flen = 16;
      if (isRvf())
	flen = 32;
      if (isRvd())
	flen = 64;
      fpRegs_.setFlen(flen);
      fpRegs_.reset(isRvzfh(), isRvf(), isRvd());
    }

#ifdef SOFT_FLOAT

  softfloat_exceptionFlags = 0;
  softfloat_detectTininess = softfloat_tininess_afterRounding;

#endif
}


template <typename URV>
void
Hart<URV>::orFcsrFlags(FpFlags flags)
{
  if (triggerTripped_)
    return;

  fpRegs_.setLastFpFlags(unsigned(flags));

  auto prev = getFpFlags();
  auto val = prev | unsigned(flags);
  if (val != prev)
    {
      setFpFlags(val);
      recordCsrWrite(CsrNumber::FCSR);
    }

  // Mark FS as dirty if the instruction generated any FP flags even if they
  // are the same as the current flags.
  if (unsigned(flags))
      markFsDirty();
}


template <typename URV>
inline
RoundingMode
Hart<URV>::effectiveRoundingMode(unsigned instMode)
{
  if (forceRounding_)
    return forcedRounding_;

  if (RoundingMode(instMode) != RoundingMode::Dynamic)
    return RoundingMode(instMode);

  return getFpRoundingMode();
}


/// Return the exponent bits of the given floating point value.
unsigned
fpExponentBits(float sp)
{
  Uint32FloatUnion uf(sp);
  return (uf.u << 1) >> 24;
}


/// Return the exponent bits of the given double precision value.
unsigned
fpExponentBits(double dp)
{
  Uint64DoubleUnion ud(dp);
  return (ud.u << 1) >> 53;
}


#ifdef FAST_SLOPPY

template <typename URV>
template <typename float_type>
inline
auto
Hart<URV>::updateAccruedFpBits(float_type)
  -> typename std::enable_if<std::is_floating_point<float_type>::value>::type
{
}


template <typename URV>
inline
void
Hart<URV>::setFpStatus(FpStatus)
{
}


template <typename URV>
inline
void
Hart<URV>::markFsDirty()
{
}

#else


template <typename URV>
template <typename float_type>
auto
Hart<URV>::updateAccruedFpBits([[maybe_unused]] float_type res)
  -> typename std::enable_if<std::is_floating_point<float_type>::value, void>::type
{
  if (triggerTripped_)
    return;

  URV val = getFpFlags();
  URV prev = val;

  URV incFlags = 0; // Incremental RISCV FP flags generated by current instruction.

#ifdef SOFT_FLOAT
  int flags = softfloat_exceptionFlags;
  if (flags)
    {
      if (flags & softfloat_flag_inexact)   incFlags |= URV(FpFlags::Inexact);
      if (flags & softfloat_flag_underflow) incFlags |= URV(FpFlags::Underflow);
      if (flags & softfloat_flag_overflow)  incFlags |= URV(FpFlags::Overflow);
      if (flags & softfloat_flag_infinite)  incFlags |= URV(FpFlags::DivByZero);
      if (flags & softfloat_flag_invalid)   incFlags |= URV(FpFlags::Invalid);
    }
#else
  int flags = fetestexcept(FE_ALL_EXCEPT);
  if (flags)
    {
      if (flags & FE_INEXACT)
        incFlags |= URV(FpFlags::Inexact);
      if ((flags & FE_UNDERFLOW) and (fpExponentBits(res) == 0))
        incFlags |= URV(FpFlags::Underflow);
      if (flags & FE_OVERFLOW)
        incFlags |= URV(FpFlags::Overflow);
      if (flags & FE_DIVBYZERO)
        incFlags |= URV(FpFlags::DivByZero);
      if (flags & FE_INVALID)
        incFlags |= URV(FpFlags::Invalid);
    }
#endif

  fpRegs_.setLastFpFlags(incFlags);

  val |= incFlags;
  if (val != prev)
    {
      setFpFlags(val);
      recordCsrWrite(CsrNumber::FCSR);
    }

  // Mark FS as dirty if the instruction generated any FP flags even if they
  // are the same as the current flags.
  if (incFlags)
    markFsDirty();
}


template <typename URV>
void
Hart<URV>::setFpStatus(FpStatus value)
{
  if (mstatus_.bits_.FS != unsigned(value))
    {
      mstatus_.bits_.FS = unsigned(value);
      writeMstatus();
    }

  if (virtMode_ and mstatus_.bits_.FS != unsigned(value))
    {
      vsstatus_.bits_.FS = unsigned(value);
      csRegs_.poke(CsrNumber::VSSTATUS, vsstatus_.value_);
      recordCsrWrite(CsrNumber::VSSTATUS);
      updateCachedVsstatus();
    }
}


template <typename URV>
inline
void
Hart<URV>::markFsDirty()
{
  setFpStatus(FpStatus::Dirty);
}


#endif



#ifdef SOFT_FLOAT

static
inline
int
mapRiscvRoundingModeToSoftFloat(RoundingMode mode)
{
  static std::array<int, 5> riscvToSoftFloat =
    {
      softfloat_round_near_even,   // NearsetEven
      softfloat_round_minMag,      // Zero
      softfloat_round_min,         // Down
      softfloat_round_max,         // Up
      softfloat_round_near_maxMag  // NearestMax
    };

  uint32_t ix = uint32_t(mode);
  return riscvToSoftFloat.at(ix);
}


int
setSimulatorRoundingMode(RoundingMode mode)
{
  int previous = softfloat_roundingMode;
  softfloat_roundingMode = mapRiscvRoundingModeToSoftFloat(mode);
  return previous;
}


/// Clear the floating point flags in the machine running this
/// simulator. Do nothing in the simuated RISCV machine.
void
clearSimulatorFpFlags()
{
  softfloat_exceptionFlags = 0;
}

#else


static
inline
int
mapRiscvRoundingModeToFe(RoundingMode mode)
{
  static std::array<int, 5> riscvToFe =
    {
      FE_TONEAREST,  // NearsetEven
      FE_TOWARDZERO, // Zero
      FE_DOWNWARD,   // Down
      FE_UPWARD,     // Up
      FE_TONEAREST   // NearestMax
    };

  uint32_t ix = uint32_t(mode);
  return riscvToFe.at(ix);
}
  

int
setSimulatorRoundingMode(RoundingMode mode)
{
  int previous = std::fegetround();
  int next = mapRiscvRoundingModeToFe(mode);
  if (next != previous)
    std::fesetround(next);
  return previous;
}


/// Clear the floating point flags in the machine running this
/// simulator. Do nothing in the simulated RISCV machine.
void
clearSimulatorFpFlags()
{
#ifdef __x86_64__
  uint32_t val = _mm_getcsr();
  val &= ~uint32_t(0x3f);
  _mm_setcsr(val);
#else
  std::fexcept_t fe;
  std::fegetexceptflag(&fe, FE_ALL_EXCEPT);
  if (unsigned(fe) != 0)
    std::feclearexcept(FE_ALL_EXCEPT);
#endif
}

#endif


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeHp(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return false;
    }

  RoundingMode riscvMode = effectiveRoundingMode(di->roundingMode());
  if (riscvMode >= RoundingMode::Invalid1)
    {
      illegalInst(di);
      return false;
    }

  clearSimulatorFpFlags();
  setSimulatorRoundingMode(riscvMode);
  return true;
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeSp(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return false;
    }

  RoundingMode riscvMode = effectiveRoundingMode(di->roundingMode());
  if (riscvMode >= RoundingMode::Invalid1)
    {
      illegalInst(di);
      return false;
    }

  clearSimulatorFpFlags();
  setSimulatorRoundingMode(riscvMode);
  return true;
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeDp(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return false;
    }

  RoundingMode riscvMode = effectiveRoundingMode(di->roundingMode());
  if (riscvMode >= RoundingMode::Invalid1)
    {
      illegalInst(di);
      return false;
    }

  clearSimulatorFpFlags();
  setSimulatorRoundingMode(riscvMode);
  return true;
}


template <typename URV>
void
Hart<URV>::execFlw(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint32_t>(virtAddr, false /*hyper*/, data))
    {
      Uint32FloatUnion ufu{uint32_t(data)};
      fpRegs_.writeSingle(di->op0(), ufu.f);
      markFsDirty();
      return;
    }

  auto cause = ExceptionCause::LOAD_ACC_FAULT;
  initiateLoadException(cause, virtAddr);
}


template <typename URV>
void
Hart<URV>::execFsw(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1(), rs2 = di->op0();
  SRV imm = di->op2As<SRV>();

  URV base = intRegs_.read(rs1);
  URV addr = base + imm;

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t val = fpRegs_.readBitsRaw(rs2);

  store<uint32_t>(addr, false /*hyper*/, uint32_t(val));
}


/// Use fused mutiply-add to perform x*y + z.
/// Set invalid to true if x and y are zero and infinity or
/// vice versa since RISCV consider that as an invalid operation.
float
fusedMultiplyAdd(float x, float y, float z)
{
  float res = 0;

#ifndef SOFT_FLOAT
  #ifndef FP_FAST_FMAF
  res = x*y + z;
  #else
  res = std::fma(x, y, z);
  #endif
  if ((std::isinf(x) and y == 0) or (x == 0 and std::isinf(y)))
    std::feraiseexcept(FE_INVALID);
  if (std::isnan(res))
    res = std::numeric_limits<float>::quiet_NaN();
#else
  float32_t tmp = f32_mulAdd(nativeToSoft(x), nativeToSoft(y), nativeToSoft(z));
  res = softToNative(tmp);
#endif

  return res;
}


/// Use fused mutiply-add to perform x*y + z.
/// Set invalid to true if x and y are zero and infinity or
/// vice versa since RISCV consider that as an invalid operation.
Float16
fusedMultiplyAdd(Float16 x, Float16 y, Float16 z)
{
  Float16 res;

#ifndef SOFT_FLOAT
  #ifndef FP_FAST_FMAF
  res = Float16::fromFloat(x.toFloat() * y.toFloat() + z.toFloat());
  #else
  res = Float16::fromFloat(std::fma(x.toFloat(), y.toFloat(), z.toFloat()));
  #endif
  if ((x.isInf() and y.isZero()) or (x.isZero() and y.isInf()))
    std::feraiseexcept(FE_INVALID);
  if (res.isNan())
    res = Float16::quietNan();
#else
  float16_t tmp = f16_mulAdd(nativeToSoft(x), nativeToSoft(y), nativeToSoft(z));
  res = softToNative(tmp);
#endif

  return res;
}


/// Use fused mutiply-add to perform x*y + z.
double
fusedMultiplyAdd(double x, double y, double z)
{
  double res = 0;

#ifndef SOFT_FLOAT
  #ifndef FP_FAST_FMA
  res = x*y + z;
  #else
  res = std::fma(x, y, z);
  #endif
  if ((std::isinf(x) and y == 0) or (x == 0 and std::isinf(y)))
    std::feraiseexcept(FE_INVALID);
  if (std::isnan(res))
    res = std::numeric_limits<double>::quiet_NaN();
#else
  float64_t tmp = f64_mulAdd(nativeToSoft(x), nativeToSoft(y), nativeToSoft(z));
  res = softToNative(tmp);
#endif

  return res;
}


float
subnormalAdjust(float x)
{
  if (std::fpclassify(x) != FP_SUBNORMAL)
    return x;
  return std::signbit(x) == 0 ? 0.0 : -0.0;
}


double
subnormalAdjust(double x)
{
  if (std::fpclassify(x) != FP_SUBNORMAL)
    return x;
  return std::signbit(x) == 0 ? 0.0 : -0.0;
}


Float16
subnormalAdjust(Float16 x)
{
  if (not x.isSubnormal())
    return x;
  return x.clearMantissa();
}


template <typename URV>
void
Hart<URV>::execFmadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = -fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = -fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  float f1 = -fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = -fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

#ifdef SOFT_FLOAT
  float res = softToNative(f32_add(nativeToSoft(f1), nativeToSoft(f2)));
#else
  float res = f1 + f2;
  if (std::isnan(res))
    res = std::numeric_limits<float>::quiet_NaN();
#endif

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

#ifdef SOFT_FLOAT
  float res = softToNative(f32_sub(nativeToSoft(f1), nativeToSoft(f2)));
#else
  float res = f1 - f2;
  if (std::isnan(res))
    res = std::numeric_limits<float>::quiet_NaN();
#endif

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmul_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

#ifdef SOFT_FLOAT
  float res = softToNative(f32_mul(nativeToSoft(f1), nativeToSoft(f2)));
#else
  float res = f1 * f2;
  if (std::isnan(res))
    res = std::numeric_limits<float>::quiet_NaN();
#endif

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFdiv_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

#ifdef SOFT_FLOAT
  float res = softToNative(f32_div(nativeToSoft(f1), nativeToSoft(f2)));
#else
  float res = f1 / f2;
  if (std::isnan(res))
    res = std::numeric_limits<float>::quiet_NaN();
#endif

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsqrt_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

#ifdef SOFT_FLOAT
  float res = softToNative(f32_sqrt(nativeToSoft(f1)));
#else
  float res = std::sqrt(f1);
  if (std::isnan(res))
    res = std::numeric_limits<float>::quiet_NaN();
#endif

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnj_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = std::copysignf(f1, f2);  // Magnitude of rs1 and sign of rs2
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjn_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = std::copysignf(f1, f2);  // Magnitude of rs1 and sign of rs2
  res = -res;  // Magnitude of rs1 and negative the sign of rs2
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjx_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  int sign1 = (std::signbit(f1) == 0) ? 0 : 1;
  int sign2 = (std::signbit(f2) == 0) ? 0 : 1;
  int sign = sign1 ^ sign2;

  float x = sign? -1 : 1;

  float res = std::copysignf(f1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmin_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fminf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0F);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmax_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmaxf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0F);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_w_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  SRV result = fpConvertTo<int32_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0);
}


template <typename URV>
void
Hart<URV>::execFcvt_wu_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(f1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0f);
}


template <typename URV>
void
Hart<URV>::execFmv_x_w(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
  int32_t s1 = v1;  // Keep lower 32 bits

  SRV value = SRV(s1); // Sign extend.

  intRegs_.write(di->op0(), value);
}

 
template <typename URV>
void
Hart<URV>::execFeq_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (f1 == f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFlt_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 < f2)? 1 : 0;
    
  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFle_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename FT>
unsigned
WdRiscv::fpClassifyRiscv(FT val)
{
  unsigned result = 0;

  bool pos = not std::signbit(val);
  int type = std::fpclassify(val);

  if (type == FP_INFINITE)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosInfinity);
      else
	result |= unsigned(FpClassifyMasks::NegInfinity);
    }
  else if (type == FP_NORMAL)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosNormal);
      else
	result |= unsigned(FpClassifyMasks::NegNormal);
    }
  else if (type == FP_SUBNORMAL)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosSubnormal);
      else
	result |= unsigned(FpClassifyMasks::NegSubnormal);
    }
  else if (type == FP_ZERO)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosZero);
      else
	result |= unsigned(FpClassifyMasks::NegZero);
    }
  else if (type == FP_NAN)
    {
      if (isSnan(val))
	result |= unsigned(FpClassifyMasks::SignalingNan);
      else
	result |= unsigned(FpClassifyMasks::QuietNan);
    }

  return result;
}


template <>
unsigned
WdRiscv::fpClassifyRiscv(Float16 val)
{
  unsigned result = 0;
  bool pos = not val.signBit();

  if (val.isInf())
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosInfinity);
      else
	result |= unsigned(FpClassifyMasks::NegInfinity);
    }
  else if (val.isSubnormal())
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosSubnormal);
      else
	result |= unsigned(FpClassifyMasks::NegSubnormal);
    }
  else if (val.isZero())
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosZero);
      else
	result |= unsigned(FpClassifyMasks::NegZero);
    }
  else if (val.isNan())
    {
      if (val.isSnan())
	result |= unsigned(FpClassifyMasks::SignalingNan);
      else
	result |= unsigned(FpClassifyMasks::QuietNan);
    }
  else
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosNormal);
      else
	result |= unsigned(FpClassifyMasks::NegNormal);
    }

  return result;
}


template <typename URV>
void
Hart<URV>::execFclass_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  URV result = fpClassifyRiscv(f1);
  intRegs_.write(di->op0(), result);
}


template <typename URV>
void
Hart<URV>::execFcvt_s_w(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_wu(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  uint32_t u1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(u1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmv_w_x(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t u1 = intRegs_.read(di->op1());

  Uint32FloatUnion ufu(u1);
  fpRegs_.writeSingle(di->op0(), ufu.f);

  markFsDirty();
}


template <>
void
Hart<uint32_t>::execFcvt_l_s(const DecodedInst* di)
{
  illegalInst(di);  // fcvt.l.s is not an RV32 instruction.
}


template <>
void
Hart<uint64_t>::execFcvt_l_s(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0);
}


template <>
void
Hart<uint32_t>::execFcvt_lu_s(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.lu.s
}


template <>
void
Hart<uint64_t>::execFcvt_lu_s(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0f);

}


template <>
void
Hart<uint32_t>::execFcvt_s_l(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.lu.s
}


template <>
void
Hart<uint64_t>::execFcvt_s_l(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <>
void
Hart<uint32_t>::execFcvt_s_lu(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.s.lu
}


template <>
void
Hart<uint64_t>::execFcvt_s_lu(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  URV i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFld(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint64_t>(virtAddr, false /*hyper*/, data))
    {
      Uint64DoubleUnion udu{data};
      fpRegs_.writeDouble(di->op0(), udu.d);

      markFsDirty();
      return;
    }

  auto cause = ExceptionCause::LOAD_ACC_FAULT;
  initiateLoadException(cause, virtAddr);
}


template <typename URV>
void
Hart<URV>::execFsd(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1();
  uint32_t rs2 = di->op0();

  URV base = intRegs_.read(rs1);
  URV addr = base + di->op2As<SRV>();
  double val = fpRegs_.readDouble(rs2);

  Uint64DoubleUnion udu{val};

  store<uint64_t>(addr, false /*hyper*/, udu.u);
}


template <typename URV>
void
Hart<URV>::execFmadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = -fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = -fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  double f1 = -fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = -fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

#ifdef SOFT_FLOAT
  double res = softToNative(f64_add(nativeToSoft(d1), nativeToSoft(d2)));
#else
  double res = d1 + d2;
  if (std::isnan(res))
    res = std::numeric_limits<double>::quiet_NaN();
#endif

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

#ifdef SOFT_FLOAT
  double res = softToNative(f64_sub(nativeToSoft(d1), nativeToSoft(d2)));
#else
  double res = d1 - d2;
  if (std::isnan(res))
    res = std::numeric_limits<double>::quiet_NaN();
#endif

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmul_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

#ifdef SOFT_FLOAT
  double res = softToNative(f64_mul(nativeToSoft(d1), nativeToSoft(d2)));
#else
  double res = d1 * d2;
  if (std::isnan(res))
    res = std::numeric_limits<double>::quiet_NaN();
#endif

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFdiv_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

#ifdef SOFT_FLOAT
  double res = softToNative(f64_div(nativeToSoft(d1), nativeToSoft(d2)));
#else
  double res = d1 / d2;
  if (std::isnan(res))
    res = std::numeric_limits<double>::quiet_NaN();
#endif

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnj_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = copysign(d1, d2);  // Magnitude of rs1 and sign of rs2
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjn_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = copysign(d1, d2);  // Magnitude of rs1 and sign of rs2
  res = -res;  // Magnitude of rs1 and negative the sign of rs2
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjx_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  int sign1 = (std::signbit(d1) == 0) ? 0 : 1;
  int sign2 = (std::signbit(d2) == 0) ? 0 : 1;
  int sign = sign1 ^ sign2;

  double x = sign? -1 : 1;

  double res = copysign(d1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmin_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmax_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_s(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  double res = fpConvertTo<double, true>(f1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  float res = fpConvertTo<float, true>(d1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsqrt_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

#ifdef SOFT_FLOAT
  double res = softToNative(f64_sqrt(nativeToSoft(d1)));
#else
  double res = std::sqrt(d1);
  if (std::isnan(res))
    res = std::numeric_limits<double>::quiet_NaN();
#endif

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFle_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (d1 <= d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFlt_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (d1 < d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFeq_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    {
      if (isSnan(d1) or isSnan(d2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (d1 == d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFcvt_w_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  SRV result = fpConvertTo<int32_t>(d1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0);

}



template <typename URV>
void
Hart<URV>::execFcvt_wu_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(d1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0f);

}


template <typename URV>
void
Hart<URV>::execFcvt_d_w(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_wu(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  uint32_t i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFclass_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  URV result = fpClassifyRiscv(d1);
  intRegs_.write(di->op0(), result);
}


template <>
void
Hart<uint32_t>::execFcvt_l_d(const DecodedInst* di)
{
  illegalInst(di);  // fcvt.l.d not available in RV32
}


template <>
void
Hart<uint64_t>::execFcvt_l_d(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0);

}


template <>
void
Hart<uint32_t>::execFcvt_lu_d(const DecodedInst* di)
{
  illegalInst(di);  /// fcvt.lu.d is not available in RV32.
}


template <>
void
Hart<uint64_t>::execFcvt_lu_d(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0f);

}


template <typename URV>
void
Hart<URV>::execFcvt_d_l(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_lu(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  URV i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmv_d_x(const DecodedInst* di)
{
  if (not isRv64() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  uint64_t u1 = intRegs_.read(di->op1());

  Uint64DoubleUnion udu{u1};

  fpRegs_.writeDouble(di->op0(), udu.d);

  markFsDirty();
}


// In 32-bit harts, fmv_x_d is an illegal instruction.
template <>
void
Hart<uint32_t>::execFmv_x_d(const DecodedInst* di)
{
  illegalInst(di);
}


template <>
void
Hart<uint64_t>::execFmv_x_d(const DecodedInst* di)
{
  if (not isRv64() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  URV v1 = fpRegs_.readBitsRaw(di->op1());
  intRegs_.write(di->op0(), v1);
}


template<typename URV>
void
Hart<URV>::execFlh(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint16_t>(virtAddr, false /*hyper*/,  data))
    {
      Float16 f16 = Float16::fromBits(data);
      fpRegs_.writeHalf(di->op0(), f16);
      markFsDirty();
      return;
    }

  auto cause = ExceptionCause::LOAD_ACC_FAULT;
  initiateLoadException(cause, virtAddr);
}


template<typename URV>
void
Hart<URV>::execFsh(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1(), rs2 = di->op0();
  SRV imm = di->op2As<SRV>();

  URV base = intRegs_.read(rs1);
  URV addr = base + imm;

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint16_t val = fpRegs_.readBitsRaw(rs2);

  store<uint16_t>(addr, false /*hyper*/, val);
}


template<typename URV>
void
Hart<URV>::execFmadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3()).negate();

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFnmsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1()).negate();
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFnmadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  Float16 f1 = fpRegs_.readHalf(di->op1()).negate();
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3()).negate();

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

#ifdef SOFT_FLOAT
  Float16 res = softToNative(f16_add(nativeToSoft(f1), nativeToSoft(f2)));
#else
  Float16 res = Float16::fromFloat(f1.toFloat() + f2.toFloat());
  if (res.isNan())
    res = Float16::quietNan();
#endif

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

#ifdef SOFT_FLOAT
  Float16 res = softToNative(f16_sub(nativeToSoft(f1), nativeToSoft(f2)));
#else
  Float16 res = Float16::fromFloat(f1.toFloat() - f2.toFloat());
  if (res.isNan())
    res = Float16::quietNan();
#endif

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmul_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

#ifdef SOFT_FLOAT
  Float16 res = softToNative(f16_mul(nativeToSoft(f1), nativeToSoft(f2)));
#else
  Float16 res = Float16::fromFloat(f1.toFloat() * f2.toFloat());
  if (res.isNan())
    res = Float16::quietNan();
#endif

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFdiv_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

#ifdef SOFT_FLOAT
  Float16 res = softToNative(f16_div(nativeToSoft(f1), nativeToSoft(f2)));
#else
  Float16 res = Float16::fromFloat(f1.toFloat() / f2.toFloat());
  if (res.isNan())
    res = Float16::quietNan();
#endif

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsqrt_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

#ifdef SOFT_FLOAT
  Float16 res = softToNative(f16_sqrt(nativeToSoft(f1)));
#else
  Float16 res = Float16::fromFloat(std::sqrt(f1.toFloat()));
  if (res.isNan())
    res = Float16::quietNan();
#endif

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnj_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = Float16::copySign(f1, f2);  // Magnitude of f1 and sign of f2
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnjn_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = Float16::copySign(f1, f2);  // Magnitude of f1 and sign of f2
  res = res.negate();  // Magnitude of f1 and negative the sign of f2
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnjx_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  unsigned sign1 = f1.signBit();
  unsigned sign2 = f2.signBit();
  unsigned sign = sign1 ^ sign2;

  Float16 res = sign != sign1? -f1 : f1;
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmin_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = in1.isNan(), isNan2 = in2.isNan();
  if (isNan1 and isNan2)
    res = Float16::quietNan();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = Float16::fromFloat(std::fminf(in1.toFloat(), in2.toFloat()));

  if (in1.isSnan() or in2.isSnan())
    orFcsrFlags(FpFlags::Invalid);
  else if (in1.signBit() != in2.signBit() and in1 == in2)
    res.setSign();  // Make sure min(-0, +0) is -0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmax_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = in1.isNan(), isNan2 = in2.isNan();
  if (isNan1 and isNan2)
    res = Float16::quietNan();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = Float16::fromFloat(std::fmaxf(in1.toFloat(), in2.toFloat()));

  if (in1.isSnan() or in2.isSnan())
    orFcsrFlags(FpFlags::Invalid);
  else if (in1.signBit() != in2.signBit() and in1 == in2)
    res.clearSign();  // Make sure max(-0, +0) is +0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_s_h(const DecodedInst* di)
{
  // Half to single

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  float res = fpConvertTo<float, true>(f1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_d_h(const DecodedInst* di)
{
  // Half to double

  if (not isRvd() or (not isZfhLegal() and not isZfhminLegal()))
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  double res = fpConvertTo<double, true>(f1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits(res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_s(const DecodedInst* di)
{
  // Single to half.

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  Float16 res = fpConvertTo<Float16, true>(f1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_d(const DecodedInst* di)
{
  // Double to half.

  if (not isRvd() or (not isZfhLegal() and not isZfhminLegal()))
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  Float16 res = fpConvertTo<Float16, true>(d1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_w_h(const DecodedInst* di)
{
  // Half to integer word.

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  SRV result = fpConvertTo<int32_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0);

}


template<typename URV>
void
Hart<URV>::execFcvt_wu_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(f1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0f);
}


template<typename URV>
void
Hart<URV>::execFmv_x_h(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
  int16_t s1 = v1;  // Keep lower 32 bits

  SRV value = SRV(s1); // Sign extend.

  intRegs_.write(di->op0(), value);
}


template<typename URV>
void
Hart<URV>::execFeq_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readHalf(di->op1()).toFloat();
  float f2 = fpRegs_.readHalf(di->op2()).toFloat();

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (f1 == f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFlt_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readHalf(di->op1()).toFloat();
  float f2 = fpRegs_.readHalf(di->op2()).toFloat();

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 < f2)? 1 : 0;
    
  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFle_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readHalf(di->op1()).toFloat();
  float f2 = fpRegs_.readHalf(di->op2()).toFloat();

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 <= f2)? 1 : 0;
    
  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFclass_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  URV result = fpClassifyRiscv(f1);
  intRegs_.write(di->op0(), result);
}


template<typename URV>
void
Hart<URV>::execFcvt_h_w(const DecodedInst* di)
{
  // Integer word to half fp.

  if (not checkRoundingModeHp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(i1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_wu(const DecodedInst* di)
{
  // Integer word to half fp.

  if (not checkRoundingModeHp(di))
    return;

  uint32_t u1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(u1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmv_h_x(const DecodedInst* di)
{
  // move bits of integer register to half fp

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  URV u1 = intRegs_.read(di->op1());

  Float16 f16 = Float16::fromBits(uint16_t(u1));

  fpRegs_.writeHalf(di->op0(), f16);

  markFsDirty();
}


template<>
void
Hart<uint32_t>::execFcvt_l_h(const DecodedInst* di)
{
  illegalInst(di);
}

template <>
void
Hart<uint64_t>::execFcvt_l_h(const DecodedInst* di)
{
  // half-precision to uin64_t

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0);
}


template<>
void
Hart<uint32_t>::execFcvt_lu_h(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_lu_h(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits(0.0f);
}


template<>
void
Hart<uint32_t>::execFcvt_h_l(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_h_l(const DecodedInst* di)
{
  // int64_t to half fp

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(i1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());

  markFsDirty();
}


template<>
void
Hart<uint32_t>::execFcvt_h_lu(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_h_lu(const DecodedInst* di)
{
  // uint64_t to half fp

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  URV u1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(u1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits(res.toFloat());

  markFsDirty();
}


template class WdRiscv::Hart<uint32_t>;
template class WdRiscv::Hart<uint64_t>;

template unsigned WdRiscv::fpClassifyRiscv<float>(float);
template unsigned WdRiscv::fpClassifyRiscv<double>(double);

template void WdRiscv::Hart<uint32_t>::updateAccruedFpBits<float>(float);
template void WdRiscv::Hart<uint32_t>::updateAccruedFpBits<double>(double);
template void WdRiscv::Hart<uint64_t>::updateAccruedFpBits<float>(float);
template void WdRiscv::Hart<uint64_t>::updateAccruedFpBits<double>(double);
