// Copyright 2020 Western Digital Corporation or its affiliates.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// This file contains the methods of the class Hart supporting
// the RISCV floating point instructions.

#include <cfenv>
#include <cmath>
#include <array>
#include "Hart.hpp"
#include "instforms.hpp"
#include "float-util.hpp"


using namespace WdRiscv;


template <typename URV>
void
Hart<URV>::enableRvf(bool flag)
{
  enableExtension(RvExtension::F, flag);
  csRegs_.enableRvf(flag);
  if (not flag)
    setFpStatus(FpStatus::Off);
}


template <typename URV>
void
Hart<URV>::resetFloat()
{
  // Enable FP in MSTATUS.FS if f/d/zfh extension present and linux/newlib.
  bool hasFp = isRvf() or isRvd() or isRvzfh();
  if (hasFp and (newlib_ or linux_))
    {
      URV val = csRegs_.peekMstatus();
      MstatusFields<URV> fields(val);
      fields.bits_.FS = unsigned(FpStatus::Initial);
      csRegs_.write(CsrNumber::MSTATUS, PrivilegeMode::Machine, fields.value_);
    }

  if (hasFp)
    {
      unsigned flen = 16;
      if (isRvf())
	flen = 32;
      if (isRvd())
	flen = 64;
      fpRegs_.setFlen(flen);
      fpRegs_.reset(isRvzfh(), isRvf(), isRvd());
    }

  clearSimulatorFpFlags();
}


template <typename URV>
void
Hart<URV>::orFcsrFlags(FpFlags flags)
{
  if (triggerTripped_)
    return;

  fpRegs_.setLastFpFlags(unsigned(flags));

  auto prev = getFpFlags();
  auto val = prev | unsigned(flags);
  if (val != prev)
    {
      setFpFlags(val);
      recordCsrWrite(CsrNumber::FCSR);
    }

  // Mark FS as dirty if the instruction generated any FP flags even if they
  // are the same as the current flags.
  if (unsigned(flags))
    markFsDirty();
}


template <typename URV>
inline
RoundingMode
Hart<URV>::effectiveRoundingMode(unsigned instMode)
{
  if (forceRounding_)
    return forcedRounding_;

  if (RoundingMode(instMode) != RoundingMode::Dynamic)
    return RoundingMode(instMode);

  return getFpRoundingMode();
}


#ifdef FAST_SLOPPY

template <typename URV>
inline
void
Hart<URV>::updateAccruedFpBits()
{
}


template <typename URV>
inline
void
Hart<URV>::setFpStatus(FpStatus)
{
}


template <typename URV>
inline
void
Hart<URV>::markFsDirty()
{
}

#else


template <typename URV>
void
Hart<URV>::updateAccruedFpBits()
{
  if (triggerTripped_)
    return;

  URV val = getFpFlags();
  URV prev = val;

  URV incFlags = activeSimulatorFpFlags(); // Incremental RISCV FP flags generated by current instruction.

  fpRegs_.setLastFpFlags(incFlags);

  val |= incFlags;
  if (val != prev)
    {
      setFpFlags(val);
      recordCsrWrite(CsrNumber::FCSR);
    }

  // Mark FS as dirty if the instruction generated any FP flags even if they
  // are the same as the current flags.
  if (incFlags)
    markFsDirty();
}


template <typename URV>
void
Hart<URV>::setFpStatus(FpStatus value)
{
  if (mstatus_.bits_.FS != unsigned(value))
    {
      mstatus_.bits_.FS = unsigned(value);
      writeMstatus();
    }

  if (virtMode_ and vsstatus_.bits_.FS != unsigned(value))
    {
      vsstatus_.bits_.FS = unsigned(value);
      csRegs_.poke(CsrNumber::VSSTATUS, vsstatus_.value_);
      recordCsrWrite(CsrNumber::VSSTATUS);
      updateCachedVsstatus();
    }
}


template <typename URV>
inline
void
Hart<URV>::markFsDirty()
{
  setFpStatus(FpStatus::Dirty);
}


#endif


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeCommon(const DecodedInst* di)
{
  RoundingMode riscvMode = effectiveRoundingMode(di->roundingMode());
  if (riscvMode >= RoundingMode::Invalid1)
    {
      illegalInst(di);
      return false;
    }

  clearSimulatorFpFlags();
  setSimulatorRoundingMode(riscvMode);
  return true;
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeHp(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeSp(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeDp(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
inline
bool
Hart<URV>::checkRoundingModeBf16(const DecodedInst* di)
{
  if (not isZfbfminLegal())
    {
      illegalInst(di);
      return false;
    }

  return checkRoundingModeCommon(di);
}


template <typename URV>
void
Hart<URV>::execFlw(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint32_t>(virtAddr, false /*hyper*/, data))
    {
      fpRegs_.writeSingle(di->op0(), std::bit_cast<float>(static_cast<uint32_t>(data)));
      markFsDirty();
      return;
    }

  auto cause = ExceptionCause::LOAD_ACC_FAULT;
  initiateLoadException(cause, virtAddr);
}


template <typename URV>
void
Hart<URV>::execFsw(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1(), rs2 = di->op0();
  SRV imm = di->op2As<SRV>();

  URV base = intRegs_.read(rs1);
  URV addr = base + imm;

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t val = fpRegs_.readBitsRaw(rs2);

  store<uint32_t>(addr, false /*hyper*/, uint32_t(val));
}


template <typename URV>
void
Hart<URV>::execFmadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = -fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = -fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  float f1 = -fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float f3 = -fpRegs_.readSingle(di->op3());

  float res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFadd_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFadd(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsub_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFadd(f1, -f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmul_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFmul(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFdiv_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = doFdiv(f1, f2);
  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsqrt_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  float res = doFsqrt(f1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnj_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = std::copysignf(f1, f2);  // Magnitude of rs1 and sign of rs2
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjn_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());
  float res = std::copysignf(f1, f2);  // Magnitude of rs1 and sign of rs2
  res = -res;  // Magnitude of rs1 and negative the sign of rs2
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjx_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  int sign1 = (std::signbit(f1) == 0) ? 0 : 1;
  int sign2 = (std::signbit(f2) == 0) ? 0 : 1;
  int sign = sign1 ^ sign2;

  float x = sign? -1 : 1;

  float res = std::copysignf(f1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmin_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fminf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0F);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmax_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmaxf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0F);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_w_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  SRV result = fpConvertTo<int32_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <typename URV>
void
Hart<URV>::execFcvt_wu_s(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(f1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <typename URV>
void
Hart<URV>::execFmv_x_w(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
  int32_t s1 = v1;  // Keep lower 32 bits

  SRV value = SRV(s1); // Sign extend.

  intRegs_.write(di->op0(), value);
}

 
template <typename URV>
void
Hart<URV>::execFeq_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (f1 == f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFlt_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 < f2)? 1 : 0;
    
  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFle_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename FT>
unsigned
WdRiscv::fpClassifyRiscv(FT val)
{
  unsigned result = 0;

  bool pos = not std::signbit(val);
  int type = std::fpclassify(val);

  if (type == FP_INFINITE)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosInfinity);
      else
	result |= unsigned(FpClassifyMasks::NegInfinity);
    }
  else if (type == FP_NORMAL)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosNormal);
      else
	result |= unsigned(FpClassifyMasks::NegNormal);
    }
  else if (type == FP_SUBNORMAL)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosSubnormal);
      else
	result |= unsigned(FpClassifyMasks::NegSubnormal);
    }
  else if (type == FP_ZERO)
    {
      if (pos)
	result |= unsigned(FpClassifyMasks::PosZero);
      else
	result |= unsigned(FpClassifyMasks::NegZero);
    }
  else if (type == FP_NAN)
    {
      if (isSnan(val))
	result |= unsigned(FpClassifyMasks::SignalingNan);
      else
	result |= unsigned(FpClassifyMasks::QuietNan);
    }

  return result;
}


template <typename URV>
void
Hart<URV>::execFclass_s(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  URV result = fpClassifyRiscv(f1);
  intRegs_.write(di->op0(), result);
}


template <typename URV>
void
Hart<URV>::execFcvt_s_w(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_wu(const DecodedInst* di)
{
  if (not checkRoundingModeSp(di))
    return;

  uint32_t u1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(u1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmv_w_x(const DecodedInst* di)
{
  if (not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t u1 = intRegs_.read(di->op1());

  fpRegs_.writeSingle(di->op0(), std::bit_cast<float>(u1));

  markFsDirty();
}


template <>
void
Hart<uint32_t>::execFcvt_l_s(const DecodedInst* di)
{
  illegalInst(di);  // fcvt.l.s is not an RV32 instruction.
}


template <>
void
Hart<uint64_t>::execFcvt_l_s(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template <>
void
Hart<uint32_t>::execFcvt_lu_s(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.lu.s
}


template <>
void
Hart<uint64_t>::execFcvt_lu_s(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <>
void
Hart<uint32_t>::execFcvt_s_l(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.lu.s
}


template <>
void
Hart<uint64_t>::execFcvt_s_l(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <>
void
Hart<uint32_t>::execFcvt_s_lu(const DecodedInst* di)
{
  illegalInst(di);  // RV32 does not have fcvt.s.lu
}


template <>
void
Hart<uint64_t>::execFcvt_s_lu(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeSp(di))
    return;

  URV i1 = intRegs_.read(di->op1());

  float res = fpConvertTo<float>(i1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFld(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint64_t>(virtAddr, false /*hyper*/, data))
    {
      fpRegs_.writeDouble(di->op0(), std::bit_cast<double>(data));

      markFsDirty();
      return;
    }

  auto cause = ExceptionCause::LOAD_ACC_FAULT;
  initiateLoadException(cause, virtAddr);
}


template <typename URV>
void
Hart<URV>::execFsd(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1();
  uint32_t rs2 = di->op0();

  URV base = intRegs_.read(rs1);
  URV addr = base + di->op2As<SRV>();
  double val = fpRegs_.readDouble(rs2);

  store<uint64_t>(addr, false /*hyper*/, std::bit_cast<uint64_t>(val));
}


template <typename URV>
void
Hart<URV>::execFmadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = -fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double f1 = -fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFnmadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  double f1 = -fpRegs_.readDouble(di->op1());
  double f2 = fpRegs_.readDouble(di->op2());
  double f3 = -fpRegs_.readDouble(di->op3());

  double res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFadd_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFadd(d1, d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsub_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFadd(d1, -d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmul_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFmul(d1, d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFdiv_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = doFdiv(d1, d2);
  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnj_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = copysign(d1, d2);  // Magnitude of rs1 and sign of rs2
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjn_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());
  double res = copysign(d1, d2);  // Magnitude of rs1 and sign of rs2
  res = -res;  // Magnitude of rs1 and negative the sign of rs2
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsgnjx_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  int sign1 = (std::signbit(d1) == 0) ? 0 : 1;
  int sign2 = (std::signbit(d2) == 0) ? 0 : 1;
  int sign = sign1 ^ sign2;

  double x = sign? -1 : 1;

  double res = copysign(d1, x);  // Magnitude of rs1 and sign of x
  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmin_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmax_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_s(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  double res = fpConvertTo<double, true>(f1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  float res = fpConvertTo<float, false>(d1);
  res       = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFsqrt_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  double res = doFsqrt(d1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFle_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (d1 <= d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFlt_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (d1 < d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFeq_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    {
      if (isSnan(d1) or isSnan(d2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (d1 == d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFcvt_w_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  SRV result = fpConvertTo<int32_t>(d1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}



template <typename URV>
void
Hart<URV>::execFcvt_wu_d(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(d1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <typename URV>
void
Hart<URV>::execFcvt_d_w(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_wu(const DecodedInst* di)
{
  if (not checkRoundingModeDp(di))
    return;

  uint32_t i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFclass_d(const DecodedInst* di)
{
  if (not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  URV result = fpClassifyRiscv(d1);
  intRegs_.write(di->op0(), result);
}


template <>
void
Hart<uint32_t>::execFcvt_l_d(const DecodedInst* di)
{
  illegalInst(di);  // fcvt.l.d not available in RV32
}


template <>
void
Hart<uint64_t>::execFcvt_l_d(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <>
void
Hart<uint32_t>::execFcvt_lu_d(const DecodedInst* di)
{
  illegalInst(di);  /// fcvt.lu.d is not available in RV32.
}


template <>
void
Hart<uint64_t>::execFcvt_lu_d(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  double f1 = fpRegs_.readDouble(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template <typename URV>
void
Hart<URV>::execFcvt_d_l(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_d_lu(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeDp(di))
    return;

  URV i1 = intRegs_.read(di->op1());

  double res = fpConvertTo<double>(i1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmv_d_x(const DecodedInst* di)
{
  if (not isRv64() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  uint64_t u1 = intRegs_.read(di->op1());

  fpRegs_.writeDouble(di->op0(), std::bit_cast<double>(u1));

  markFsDirty();
}


// In 32-bit harts, fmv_x_d is an illegal instruction.
template <>
void
Hart<uint32_t>::execFmv_x_d(const DecodedInst* di)
{
  illegalInst(di);
}


template <>
void
Hart<uint64_t>::execFmv_x_d(const DecodedInst* di)
{
  if (not isRv64() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  URV v1 = fpRegs_.readBitsRaw(di->op1());
  intRegs_.write(di->op0(), v1);
}


template<typename URV>
void
Hart<URV>::execFlh(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  URV base = intRegs_.read(di->op1());
  uint64_t virtAddr = base + di->op2As<int32_t>();

  uint64_t data = 0;
  if (load<uint16_t>(virtAddr, false /*hyper*/,  data))
    {
      fpRegs_.writeHalf(di->op0(), std::bit_cast<Float16>(static_cast<uint16_t>(data)));
      markFsDirty();
      return;
    }

  auto cause = ExceptionCause::LOAD_ACC_FAULT;
  initiateLoadException(cause, virtAddr);
}


template<typename URV>
void
Hart<URV>::execFsh(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  uint32_t rs1 = di->op1(), rs2 = di->op0();
  SRV imm = di->op2As<SRV>();

  URV base = intRegs_.read(rs1);
  URV addr = base + imm;

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint16_t val = fpRegs_.readBitsRaw(rs2);

  store<uint16_t>(addr, false /*hyper*/, val);
}


template<typename URV>
void
Hart<URV>::execFmadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = -fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFnmsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = -fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFnmadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  // we want -(f[op1] * f[op2]) - f[op3]

  Float16 f1 = -fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 f3 = -fpRegs_.readHalf(di->op3());

  Float16 res = fusedMultiplyAdd(f1, f2, f3);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFadd_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFadd(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsub_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFadd(f1, -f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmul_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFmul(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFdiv_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = doFdiv(f1, f2);
  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsqrt_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  Float16 res = doFsqrt(f1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnj_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = std::copysign(f1, f2);  // Magnitude of f1 and sign of f2
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnjn_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());
  Float16 res = std::copysign(f1, f2);  // Magnitude of f1 and sign of f2
  res = -res;  // Magnitude of f1 and negative the sign of f2
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFsgnjx_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  unsigned sign1 = std::signbit(f1);
  unsigned sign2 = std::signbit(f2);
  unsigned sign = sign1 ^ sign2;

  Float16 res = sign != sign1? -f1 : f1;
  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmin_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -Float16{});  // Make sure min(-0, +0) is -0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmax_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 and isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else if (isNan1)
    res = in2;
  else if (isNan2)
    res = in1;
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, Float16{});  // Make sure max(-0, +0) is +0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_s_h(const DecodedInst* di)
{
  // Half to single

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  float res = fpConvertTo<float, true>(f1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_d_h(const DecodedInst* di)
{
  // Half to double

  if (not isRvd() or (not isZfhLegal() and not isZfhminLegal()))
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  double res = fpConvertTo<double, true>(f1);

  fpRegs_.writeDouble(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_s(const DecodedInst* di)
{
  // Single to half.

  if (not isZfhLegal() and not isZfhminLegal())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  Float16 res = fpConvertTo<Float16, false>(f1);
  res         = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_d(const DecodedInst* di)
{
  // Double to half.

  if (not isRvd() or (not isZfhLegal() and not isZfhminLegal()))
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  double d1 = fpRegs_.readDouble(di->op1());

  Float16 res = fpConvertTo<Float16, false>(d1);
  res         = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_w_h(const DecodedInst* di)
{
  // Half to integer word.

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  SRV result = fpConvertTo<int32_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();

}


template<typename URV>
void
Hart<URV>::execFcvt_wu_h(const DecodedInst* di)
{
  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  // In 64-bit mode, we sign extend the result to 64-bits.
  URV result = static_cast<SRV>(static_cast<int32_t>(fpConvertTo<uint32_t>(f1)));

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template<typename URV>
void
Hart<URV>::execFmv_x_h(const DecodedInst* di)
{
  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  // This operation does not check for proper NAN boxing. We read raw bits.
  uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
  int16_t s1 = v1;  // Keep lower 32 bits

  SRV value = SRV(s1); // Sign extend.

  intRegs_.write(di->op0(), value);
}


template<typename URV>
void
Hart<URV>::execFeq_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    {
      if (isSnan(f1) or isSnan(f2))
        orFcsrFlags(FpFlags::Invalid);
    }
  else
    res = (f1 == f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFlt_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 < f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFle_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    orFcsrFlags(FpFlags::Invalid);
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template<typename URV>
void
Hart<URV>::execFclass_h(const DecodedInst* di)
{
  if (not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  URV result = fpClassifyRiscv(f1);
  intRegs_.write(di->op0(), result);
}


template<typename URV>
void
Hart<URV>::execFcvt_h_w(const DecodedInst* di)
{
  // Integer word to half fp.

  if (not checkRoundingModeHp(di))
    return;

  int32_t i1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(i1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_h_wu(const DecodedInst* di)
{
  // Integer word to half fp.

  if (not checkRoundingModeHp(di))
    return;

  uint32_t u1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(u1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFmv_h_x(const DecodedInst* di)
{
  // move bits of integer register to half fp

  if (not isZfhLegal() and not isZfhminLegal() and not isZfbfminLegal())
    {
      illegalInst(di);
      return;
    }

  URV u1 = intRegs_.read(di->op1());

  fpRegs_.writeHalf(di->op0(), std::bit_cast<Float16>(static_cast<uint16_t>(u1)));

  markFsDirty();
}


template<>
void
Hart<uint32_t>::execFcvt_l_h(const DecodedInst* di)
{
  illegalInst(di);
}

template <>
void
Hart<uint64_t>::execFcvt_l_h(const DecodedInst* di)
{
  // half-precision to uin64_t

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  SRV result = fpConvertTo<int64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template<>
void
Hart<uint32_t>::execFcvt_lu_h(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_lu_h(const DecodedInst* di)
{
  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  Float16 f1 = fpRegs_.readHalf(di->op1());

  URV result = fpConvertTo<uint64_t>(f1);

  intRegs_.write(di->op0(), result);

  updateAccruedFpBits();
}


template<>
void
Hart<uint32_t>::execFcvt_h_l(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_h_l(const DecodedInst* di)
{
  // int64_t to half fp

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  SRV i1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(i1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template<>
void
Hart<uint32_t>::execFcvt_h_lu(const DecodedInst* di)
{
  illegalInst(di);
}


template<>
void
Hart<uint64_t>::execFcvt_h_lu(const DecodedInst* di)
{
  // uint64_t to half fp

  if (not isRv64())
    {
      illegalInst(di);
      return;
    }

  if (not checkRoundingModeHp(di))
    return;

  URV u1 = intRegs_.read(di->op1());

  Float16 res = fpConvertTo<Float16>(u1);

  fpRegs_.writeHalf(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}



template <typename URV>
void
Hart<URV>::execFcvtmod_w_d(const DecodedInst* di)
{
  if (not isRvzfa())
    {
      illegalInst(di);
      return;
    }
  illegalInst(di);
}


template <typename URV>
void
Hart<URV>::execFli_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 res{};

  switch(di->op1())
    {
    case 0:  res = fpConvertTo<Float16,true>(-1.0f);           break;
    case 1:  res = std::bit_cast<Float16>(uint16_t(0x0400));   break;  // min normal
    case 2:  res = fpConvertTo<Float16,true>(1.0f / 65536.0f); break;  // 2 to the -16
    case 3:  res = fpConvertTo<Float16,true>(1.0f / 32768.0f); break;  // 2 to the -15
    case 4:  res = fpConvertTo<Float16,true>(1.0f / 256.0f);   break;  // 2 to the -8
    case 5:  res = fpConvertTo<Float16,true>(1.0f / 128.0f);   break;  // 2 to the -7
    case 6:  res = fpConvertTo<Float16,true>(0.0625f);         break;  // 2 to the -4
    case 7:  res = fpConvertTo<Float16,true>(0.125f);          break;  // 2 to the -3
    case 8:  res = fpConvertTo<Float16,true>(0.25f);           break;  // 1/4
    case 9:  res = fpConvertTo<Float16,true>(0.3125f);         break;  // 10/32
    case 10: res = fpConvertTo<Float16,true>(0.375f);          break;  // 3/8
    case 11: res = fpConvertTo<Float16,true>(0.4375f);         break;  // 7/16
    case 12: res = fpConvertTo<Float16,true>(0.5f);            break;  // 1/2
    case 13: res = fpConvertTo<Float16,true>(0.625f);          break;  // 5/8
    case 14: res = fpConvertTo<Float16,true>(0.75f);           break;  // 3/4
    case 15: res = fpConvertTo<Float16,true>(0.875f);          break;  // 7/8
    case 16: res = fpConvertTo<Float16,true>(1.0f);            break; 
    case 17: res = fpConvertTo<Float16,true>(1.25f);           break; 
    case 18: res = fpConvertTo<Float16,true>(1.5f);            break; 
    case 20: res = fpConvertTo<Float16,true>(2.0f);            break; 
    case 21: res = fpConvertTo<Float16,true>(2.5f);            break; 
    case 22: res = fpConvertTo<Float16,true>(3.0f);            break; 
    case 23: res = fpConvertTo<Float16,true>(4.0f);            break; 
    case 24: res = fpConvertTo<Float16,true>(8.0f);            break; 
    case 25: res = fpConvertTo<Float16,true>(16.0f);           break; 
    case 26: res = fpConvertTo<Float16,true>(128.0f);          break;
    case 27: res = fpConvertTo<Float16,true>(256.0f);          break; 
    case 28: res = fpConvertTo<Float16,true>(32768.0f);        break; 
    case 29: res = std::numeric_limits<Float16>::infinity();   break;
    case 30: res = std::numeric_limits<Float16>::infinity();    break;
    case 31: res = std::numeric_limits<Float16>::quiet_NaN();  break;
    default:                                                   break;
    }

  fpRegs_.writeHalf(di->op0(), res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFli_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float res = 0;

  switch(di->op1())
    {
    case 0:  res = -1.0f;                                   break;
    case 1:  res = std::bit_cast<float>(0x00800000);        break;  // min normal
    case 2:  res = 1.0f / 65536.0f;                         break;  // 2 to the -16
    case 3:  res = 1.0f / 32768.0f;                         break;  // 2 to the -15
    case 4:  res = 1.0f / 256.0f;                           break;  // 2 to the -8
    case 5:  res = 1.0f / 128.0f;                           break;  // 2 to the -7
    case 6:  res = 0.0625f;                                 break;  // 2 to the -4
    case 7:  res = 0.125f;                                  break;  // 2 to the -3
    case 8:  res = 0.25f;                                   break;  // 1/4
    case 9:  res = 0.3125f;                                 break;  // 10/32
    case 10: res = 0.375f;                                  break;  // 3/8
    case 11: res = 0.4375f;                                 break;  // 7/16
    case 12: res = 0.5f;                                    break;  // 1/2
    case 13: res = 0.625f;                                  break;  // 5/8
    case 14: res = 0.75f;                                   break;  // 3/4
    case 15: res = 0.875f;                                  break;  // 7/8
    case 16: res = 1.0f;                                    break; 
    case 17: res = 1.25f;                                   break; 
    case 18: res = 1.5f;                                    break; 
    case 20: res = 2.0f;                                    break; 
    case 21: res = 2.5f;                                    break; 
    case 22: res = 3.0f;                                    break; 
    case 23: res = 4.0f;                                    break; 
    case 24: res = 8.0f;                                    break; 
    case 25: res = 16.0f;                                   break; 
    case 26: res = 128.0f;                                  break;
    case 27: res = 256.0f;                                  break; 
    case 28: res = 32768.0f;                                break; 
    case 29: res = 65536.0f;                                break; 
    case 30: res = std::numeric_limits<float>::infinity();  break;
    case 31: res = std::numeric_limits<float>::quiet_NaN(); break;
    default:                                                break;
    }

  fpRegs_.writeSingle(di->op0(), res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFli_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  double res = 0;
  double minNormal = std::bit_cast<double>(0x0010000000000000);

  switch(di->op1())
    {
    case 0:  res = -1.0;                                     break;
    case 1:  res = minNormal;                                break;
    case 2:  res = 1.0 / 65536.0;                            break;  // 2 to the -16
    case 3:  res = 1.0 / 32768.0;                            break;  // 2 to the -15
    case 4:  res = 1.0 / 256.0;                              break;  // 2 to the -8
    case 5:  res = 1.0 / 128.0;                              break;  // 2 to the -7
    case 6:  res = 0.0625;                                   break;  // 2 to the -4
    case 7:  res = 0.125;                                    break;  // 2 to the -3
    case 8:  res = 0.25;                                     break;  // 1/4
    case 9:  res = 0.3125;                                   break;  // 10/32
    case 10: res = 0.375;                                    break;  // 3/8
    case 11: res = 0.4375;                                   break;  // 7/16
    case 12: res = 0.5;                                      break;  // 1/2
    case 13: res = 0.625;                                    break;  // 5/8
    case 14: res = 0.75;                                     break;  // 3/4
    case 15: res = 0.875;                                    break;  // 7/8
    case 16: res = 1.0;                                      break; 
    case 17: res = 1.25;                                     break; 
    case 18: res = 1.5;                                      break; 
    case 20: res = 2.0;                                      break; 
    case 21: res = 2.5;                                      break; 
    case 22: res = 3.0;                                      break; 
    case 23: res = 4.0;                                      break; 
    case 24: res = 8.0;                                      break; 
    case 25: res = 16.0;                                     break; 
    case 26: res = 128.0;                                    break;
    case 27: res = 256.0;                                    break; 
    case 28: res = 32768.0;                                  break; 
    case 29: res = 65536.0;                                  break; 
    case 30: res = std::numeric_limits<double>::infinity();  break;
    case 31: res = std::numeric_limits<double>::quiet_NaN(); break;
    default:                                                 break;
    }

  fpRegs_.writeDouble(di->op0(), res);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFleq_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    res = 0;
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);

}


template <typename URV>
void
Hart<URV>::execFleq_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    res = 0;
  else
    res = (f1 <= f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFleq_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    res = 0;
  else
    res = (d1 <= d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFltq_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f2 = fpRegs_.readHalf(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    res = 0;
  else
    res = (f1 < f2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFltq_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f2 = fpRegs_.readSingle(di->op2());

  URV res = 0;

  if (std::isnan(f1) or std::isnan(f2))
    res = 0;
  else
    res = (f1 < f2)? 1 : 0;
    
  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFltq_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readDouble(di->op1());
  double d2 = fpRegs_.readDouble(di->op2());

  URV res = 0;

  if (std::isnan(d1) or std::isnan(d2))
    res = 0;
  else
    res = (d1 < d2)? 1 : 0;

  intRegs_.write(di->op0(), res);
}


template <typename URV>
void
Hart<URV>::execFmaxm_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }
  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, Float16{});  // Make sure max(-0, +0) is +0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmaxm_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else
    res = std::fmaxf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0F);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmaxm_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }
  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else
    res = std::fmax(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, 1.0);  // Make sure max(-0, +0) is +0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFminm_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 in1 = fpRegs_.readHalf(di->op1());
  Float16 in2 = fpRegs_.readHalf(di->op2());
  Float16 res;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<Float16>::quiet_NaN();
  else
    res = std::fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -Float16{});  // Make sure min(-0, +0) is -0.

  fpRegs_.writeHalf(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFminm_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }
  float in1 = fpRegs_.readSingle(di->op1());
  float in2 = fpRegs_.readSingle(di->op2());
  float res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<float>::quiet_NaN();
  else
    res = std::fminf(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0F);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeSingle(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFminm_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isDpLegal())
    {
      illegalInst(di);
      return;
    }

  double in1 = fpRegs_.readDouble(di->op1());
  double in2 = fpRegs_.readDouble(di->op2());
  double res = 0;

  bool isNan1 = std::isnan(in1), isNan2 = std::isnan(in2);
  if (isNan1 or isNan2)
    res = std::numeric_limits<double>::quiet_NaN();
  else
    res = fmin(in1, in2);

  if (isSnan(in1) or isSnan(in2))
    orFcsrFlags(FpFlags::Invalid);
  else if (std::signbit(in1) != std::signbit(in2) and in1 == in2)
    res = std::copysign(res, -1.0);  // Make sure min(-0, +0) is -0.

  fpRegs_.writeDouble(di->op0(), res);

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFmvh_x_d(const DecodedInst* di)
{
  if (mxlen_ == 32)
    {
      if (not isRvzfa() or not isDpLegal())
	{
	  illegalInst(di);
	  return;
	}
      uint64_t v1 = fpRegs_.readBitsRaw(di->op1());
      v1 >>= 32;
      intRegs_.write(di->op0(), v1);
    }
  else
    illegalInst(di);
}


template <typename URV>
void
Hart<URV>::execFmvp_d_x(const DecodedInst* di)
{
  if (mxlen_ == 32)
    {
      if (not isRvzfa() or not isDpLegal())
	{
	  illegalInst(di);
	  return;
	}
      uint32_t v1 = intRegs_.read(di->op1());
      uint32_t v2 = intRegs_.read(di->op2());
      uint64_t v0 = (uint64_t(v2) << 32) | v1;
      fpRegs_.writeDouble(di->op0(), std::bit_cast<double>(v0));
      markFsDirty();
    }
  else
    illegalInst(di);
}


template <typename URV>
void
Hart<URV>::execFround_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f0 = f1;

  if (isSnan(f1))
    {
      f0 = std::numeric_limits<Float16>::quiet_NaN();
      orFcsrFlags(FpFlags::Invalid);
    }
  else if (f1 == Float16{} or f1 == -Float16{} or std::isinf(f1)) // zero or infinity
    ;
  else
    {
      int exp = 0;
      std::frexp(f1, &exp);
      if (exp < 10)
	{
	  SRV intVal = fpConvertTo<int32_t>(f1);
	  f0 = fpConvertTo<Float16>(intVal);
	}
    }

  fpRegs_.writeHalf(di->op0(), f0);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFround_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f0 = f1;

  if (isSnan(f1))
    {
      f0 = std::numeric_limits<float>::quiet_NaN();
      orFcsrFlags(FpFlags::Invalid);
    }
  else if (f1 == 0 or std::isinf(f1)) // zero or infinity
    ;
  else
    {
      int exp = 0;
      std::frexp(f1, &exp);
      if (exp < 23)
	{
	  int32_t intVal = fpConvertTo<int32_t>(f1);
	  f0 = fpConvertTo<float>(intVal);
	}
    }

  fpRegs_.writeSingle(di->op0(), f0);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFround_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readSingle(di->op1());
  double d0 = d1;

  if (isSnan(d1))
    {
      d0 = std::numeric_limits<double>::quiet_NaN();
      orFcsrFlags(FpFlags::Invalid);
    }
  else if (d1 == 0 or std::isinf(d1)) // zero or infinity
    ;
  else
    {
      int exp = 0;
      std::frexp(d1, &exp);
      if (exp < 52)
	{
	  int64_t intVal = fpConvertTo<int64_t>(d1);
	  d0 = fpConvertTo<double>(intVal);
	}
    }

  fpRegs_.writeDouble(di->op0(), d0);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFroundnx_h(const DecodedInst* di)
{
  if (not isRvzfa() or not isZfhLegal())
    {
      illegalInst(di);
      return;
    }

  Float16 f1 = fpRegs_.readHalf(di->op1());
  Float16 f0 = f1;

  if (isSnan(f1))
    {
      f0 = std::numeric_limits<Float16>::quiet_NaN();
      orFcsrFlags(FpFlags::Invalid);
    }
  else if (f1 == Float16{} or f1 == -Float16{} or std::isinf(f1)) // zero or infinity
    ;
  else
    {
      int exp = 0;
      std::frexp(f1, &exp);
      if (exp < 10)
	{
	  SRV intVal = fpConvertTo<int32_t>(f1);
	  f0 = fpConvertTo<Float16>(intVal);
	  if (f0 != f1)
	    orFcsrFlags(FpFlags::Inexact);
	}
    }

  fpRegs_.writeHalf(di->op0(), f0);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFroundnx_s(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  float f1 = fpRegs_.readSingle(di->op1());
  float f0 = f1;

  if (isSnan(f1))
    {
      f0 = std::numeric_limits<float>::quiet_NaN();
      orFcsrFlags(FpFlags::Invalid);
    }
  else if (f1 == 0 or std::isinf(f1)) // zero or infinity
    ;
  else
    {
      int exp = 0;
      std::frexp(f1, &exp);
      if (exp < 23)
	{
	  int32_t intVal = fpConvertTo<int32_t>(f1);
	  f0 = fpConvertTo<float>(intVal);
	  if (f0 != f1)
	    orFcsrFlags(FpFlags::Inexact);
	}
    }

  fpRegs_.writeSingle(di->op0(), f0);
  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFroundnx_d(const DecodedInst* di)
{
  if (not isRvzfa() or not isFpLegal())
    {
      illegalInst(di);
      return;
    }

  double d1 = fpRegs_.readSingle(di->op1());
  double d0 = d1;

  if (isSnan(d1))
    {
      d0 = std::numeric_limits<double>::quiet_NaN();
      orFcsrFlags(FpFlags::Invalid);
    }
  else if (d1 == 0 or std::isinf(d1)) // zero or infinity
    ;
  else
    {
      int exp = 0;
      std::frexp(d1, &exp);
      if (exp < 52)
	{
	  int64_t intVal = fpConvertTo<int64_t>(d1);
	  d0 = fpConvertTo<double>(intVal);
	  if (d0 != d1)
	    orFcsrFlags(FpFlags::Inexact);
	}
    }

  fpRegs_.writeDouble(di->op0(), d0);
  markFsDirty();
}


template<typename URV>
void
Hart<URV>::execFcvt_bf16_s(const DecodedInst* di)
{
  // Single to bfloat16.

  if (not checkRoundingModeBf16(di))
    return;

  float f1 = fpRegs_.readSingle(di->op1());

  BFloat16 res = fpConvertTo<BFloat16, false>(f1);
  res          = maybeAdjustForTininessBeforeRoundingAndQuietNaN(res);

  fpRegs_.writeBFloat16(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template <typename URV>
void
Hart<URV>::execFcvt_s_bf16(const DecodedInst* di)
{
  if (not checkRoundingModeBf16(di))
    return;

  BFloat16 bf1 = fpRegs_.readBFloat16(di->op1());

  float res = fpConvertTo<float, true>(bf1);

  fpRegs_.writeSingle(di->op0(), res);

  updateAccruedFpBits();

  markFsDirty();
}


template class WdRiscv::Hart<uint32_t>;
template class WdRiscv::Hart<uint64_t>;

template unsigned WdRiscv::fpClassifyRiscv<Float16>(Float16);
template unsigned WdRiscv::fpClassifyRiscv<BFloat16>(BFloat16);
template unsigned WdRiscv::fpClassifyRiscv<float>(float);
template unsigned WdRiscv::fpClassifyRiscv<double>(double);
